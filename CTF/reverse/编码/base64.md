# base64

## 概念

计算机中的原始数据（如图片、音频、可执行文件等）通常是以**字节（8位）**形式存在的二进制数据。然而，某些通信协议或文本系统（如 SMTP 邮件、XML、URL 等）只能可靠地处理 **ASCII 可打印字符**（通常是 33–126 范围内的字符），无法直接传输任意字节值（尤其是 0x00–0x1F 和 0x7F–0xFF 这些控制字符或非 ASCII 字符）。

Base64 就是为了解决这个问题：**将任意二进制数据编码成仅包含 64 个安全 ASCII 字符的字符串**。

## 原理

base64使用的字符集：`A–Z（26个） a–z（26个） 0–9（10个） + 和 /（2个）`，总共64个。此外，**=** 用作填充字符（padding），不属于编码字符集，仅用于对齐。

base64的编码过程的核心思想就是`3字节 → 4字符`

步骤：

- 原始数据按 **每 3 个字节（24 位）** 为一组。
- 将这 24 位重新划分为 **4 个 6 位的单元**。
- 每个 6 位单元的值范围是 0–63，正好对应 Base64 字符表中的一个字符。
- 最终，3 个原始字节被编码为 4 个 Base64 字符。

示例：

原始字节（十六进制）：`4D 61 6E`（即 ASCII 字符 "Man"）

1. 转为二进制：
   - `01001101 01100001 01101110`
2. 拼接为 24 位：
   - `010011010110000101101110`
3. 拆分为 4 个 6 位组：
   - `010011` → 19 → 'T'
   - `010110` → 22 → 'W'
   - `000101` → 5 → 'F'
   - `101110` → 46 → 'u'

结果：`"TWFu"`

## 填充

如果原始数据长度不是 3 的倍数：

- 若余 1 字节（8 位）：补 4 个 0 成 12 位 → 得到 2 个 Base64 字符，后面加 **==**
- 若余 2 字节（16 位）：补 2 个 0 成 18 位 → 得到 3 个 Base64 字符，后面加 **=**

> 也就是说，当看到base64编码后结果有一个=号，说明原始字节数取模3余2

例如：

- `"M"`（1 字节） → 编码为 `"TQ=="`
- `"Ma"`（2 字节） → 编码为 `"TWE="`

## 解码

1. `=`不参与查表
2. 将每个base64映射回6位2进制值，例如`T`在标注表中序号是19，那么就是`010011`，以此类推
3. 按每 8 位（1 字节）切分，还原原始字节
4. 根据填充符 `=` 调整最终字节数，例如当编码后有`==`，就说明最后的4位`0`是编码时补充的，必须丢弃

## 魔改

常见变形包括：

1. 修改编码表

   方法：先找出编码结果在魔改后的表中的下标，然后在标准的编码表中相同下标位置替换

2. 修改下标

## 识别

1. 查字符串：发现有`ABCDEFGHIJ....789+/`这样的字符串，有可能是base64的字符集
2. 利用=进行padding计算
3. 查表（含有0x3F）

